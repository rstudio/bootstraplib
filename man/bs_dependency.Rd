% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bs-dependencies.R
\name{bs_dependency}
\alias{bs_dependency}
\alias{bs_dependency_defer}
\title{Compile Sass using a Bootstrap theme and create an htmlDependency object}
\usage{
bs_dependency(
  input = list(),
  theme,
  name,
  version,
  cache_key_extra = NULL,
  .dep_args = list(),
  .sass_args = list()
)

bs_dependency_defer(func)
}
\arguments{
\item{input}{Sass rules to compile, using \code{theme}.}

\item{theme}{A \code{\link[=bs_theme]{bs_theme()}} object.}

\item{name}{Library name}

\item{version}{Library version}

\item{cache_key_extra}{Extra information to add to the sass cache key. It is
useful to add the version of your package.}

\item{.dep_args}{A list of additional arguments to pass to
\code{\link[htmltools:htmlDependency]{htmltools::htmlDependency()}}.}

\item{.sass_args}{A list of additional arguments to pass to
\code{\link[sass:sass_partial]{sass::sass_partial()}}.}

\item{func}{a function that takes a \code{\link[=bs_theme]{bs_theme()}} object (or \code{theme_default})
as input and and returns an \code{\link[=htmlDependency]{htmlDependency()}} (or a list of them).}
}
\description{
HTML components can have Sass code that uses a Bootstrap theme; when the Sass
is compiled to CSS, it can read variables from the Bootstrap theme. These
functions make this possible, and also make it possible to use dynamic
theming in a Shiny application: if the Bootstrap theme is changed in a
running Shiny application, Sass code that draws on the theme will be
recompiled and sent to the browser to automatically update the appearance of
the components that use it.

\code{bs_dependency()} takes \code{input}, which is a set of sass rules, compiles it to
CSS using variables and defaults from \code{theme}, then creates an
\code{\link[htmltools:htmlDependency]{htmltools::htmlDependency()}} object for the newly-compiled CSS file. This
function isn't called directly, but instead

\code{bs_dependency_defer()} takes a \emph{function} which has one argument, \code{theme},
and that function should call \code{bs_dependency()} using that \code{theme}. The
function will be not be invoked immediately; it will be invoked when the page
is rendered. At that point, the theme will be available to be passed to it.
The function will also be invoked again if the theme is changed.
}
\examples{

\dontrun{

myWidgetVersion <- "1.2.3"

myWidgetDependency <- function() {
  list(
    bs_dependency_defer(myWidgetCss),
    htmlDependency(
      name = "mywidget-js",
      version = myWidgetVersion,
      src = system.file(package = "mypackage", "js"),
      script = "mywidget.js"
    )
  )
}

myWidgetCSS <- function(theme) {
  if (!is_bs_theme(theme)) {
    return(
      htmlDependency(
        name = "mywidget-css",
        version = myWidgetVersion,
        src = system.file(package = "mypackage", "css"),
        stylesheet = "mywidget.css"
      )
    )
  }

  # Compile mywidget.scss using the variables and defaults from the theme
  # object.
  sass_input <- sass::sass_file(system.file(package = "mypackage", "scss/mywidget.scss"))

  bs_dependency(
    input = sass_input,
    theme = theme,
    name = "mywidget",
    version = myWidgetVersion,
    cache_key_extra = utils::packageVersion("mypackage")
  )
}

# Note that myWidgetDependency is not defined inside of myWidget. This is so
# that, if `myWidget()` is called multiple times, Shiny can tell that the
# function objects are identical and deduplicate them.
myWidget <- function(id) {
  div(
    id = id,
    span("myWidget"),
    myWidgetDependency()
  )
}
}

}
