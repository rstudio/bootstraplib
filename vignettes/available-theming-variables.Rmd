---
title: "Available theming variables"
output: rmarkdown::html_vignette
author: "Nick Strayer"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{available-theming-variables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE, 
  message = FALSE
)

htmltools::tagList(
  rmarkdown::html_dependency_font_awesome(),
  rmarkdown::html_dependency_bootstrap("default")
)
```

<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>

```{r setup}
library(dplyr)
library(stringr)
library(purrr)
library(glue)
library(bslib)
```

```{css}
table.dataTable tr[role="row"] td {
  font-family: monospace;
}
table.dataTable tr[role="row"] td:nth-child(3) {
  font-family: inherit;
  font-size: 0.85rem;
}
table.dataTable tr[role="row"] td:nth-child(4) {
  text-align: center;
}

table.dataTable tr td:nth-child(1) {
  max-width: 250px;
  overflow: scroll;
}

table.dataTable tr td:nth-child(2),
table.dataTable tr td:nth-child(3){
  max-width: 300px;
  overflow: scroll;
}

table.dataTable tr td:nth-child(4){
  width: 20px;
}

.dep-link {
  color:steelblue; 
  text-decoration:underline;
  cursor: pointer;
}
.selected .dep-link {
  color: white;
}
```

```{r variables_df}
# BS3
# Not using BS3 now because the comment templates are different so a whole new scraping pipeline is needed
# sass_variables_loc <- "https://raw.githubusercontent.com/rstudio/bslib/master/inst/lib/bs-sass/assets/stylesheets/bootstrap/_variables.scss"

# BS4
sass_variables_loc <- rprojroot::find_package_root_file("inst/lib/bs/scss/_variables.scss")
sass_variables_url <- file.path(
  "https://github.com/rstudio/bslib/blob", 
   substr(system("git rev-parse HEAD", intern = TRUE), 1, 7),
  "inst/lib/bs/scss/_variables.scss"
)
# A section is denoted by a comment followed by either an empty line or an empty comment.
# e.g.
# // Section ID
#
# Or
# // Section ID
# //
#
# Sometimes the sections are just isolated floating comments
#
# // Section ID
#
#

raw_text <- brio::readLines(sass_variables_loc)

collapse_multiline_comments <- function(lines_df){

  repetitions <- rle(lines_df$is_comment & !lines_df$is_empty_comment)
  block_id <- rep(seq_along(repetitions$lengths), times = repetitions$lengths)
  is_comment_block <- rep(repetitions$values, times = repetitions$lengths)
  # A negative value means it's not a comment block. Using negatives so we
  # don't match ids of comment blocks
  lines_df$comment_block <- ifelse(is_comment_block, block_id, -seq_len(nrow(lines_df)))

  group_by(lines_df, comment_block) %>%
    summarise(
      across(c(-line), first),
      line = paste(line, collapse = " ")
    ) %>%
    arrange(line_number) %>%
    select(-comment_block)
}

link_to_pos_in_script <- function(line_num){
  paste0(sass_variables_url, "#L", line_num)
}

tibble(
  line = raw_text
) %>%
  mutate(
    line_number = row_number(),
    is_comment = str_detect(line, "^\\/\\/"),
    is_empty_comment = str_detect(line, "^\\/\\/\\s*$")
  ) %>%
  collapse_multiline_comments() %>%
  mutate(
    below_is_empty_comment = lead(is_empty_comment),
    above_is_empty_line = lag(line) == "",
    below_is_empty_line = lead(line) == "",
    is_section = (is_comment & below_is_empty_comment) | (is_comment & above_is_empty_line & below_is_empty_line),
    variable = str_extract(line, "(?<=^\\$)(.+?)(?=:)"),
    section = ifelse(is_section, str_remove(line, "\\/\\/\\s*"), NA),
    section_link = ifelse(is_section, link_to_pos_in_script(line_number), NA),
    trailing_comment = str_extract(line, "(?<=;)(.+)$"),
    above_is_comment = lag(is_comment),
    comment = case_when(
      !is.na(trailing_comment) ~ trailing_comment,
      above_is_comment ~ lag(line),
      TRUE ~ ""
    ) %>% str_remove_all("\\/\\/") %>% str_trim(),
    comment = ifelse(str_detect(comment, "stylelint-disable"), "", comment)
  ) %>%
  tidyr::fill(section, section_link) %>%
  filter(!is.na(variable)) %>%
  mutate(
    value = str_extract(line, "(?<=:)(.+)?(?=;)") %>% str_remove(fixed("!default")) %>% str_trim(),
    value_is_function = str_detect(value, fixed("()")) | str_detect(value, "\\($"),
    # map-get function is used to reference a map built earlier so make sure not
    # to link to it because there is no entry in the table to link to.
    value = str_replace_all(
      value,
      "(?<!map-get\\()(\\$[\\w|-]+)",
      "<span class='dep-link'>\\1</span>"
    ),
    section = glue("Section: {section} <a href=\"{section_link}\"><i class=\"fas fa-external-link-alt\"></i></a>"),
    declaration = glue("<a href=\"{link_to_pos_in_script(line_number)}\"><i class=\"fas fa-external-link-alt\"></i></a>")
  ) %>%
  filter(!value_is_function) %>%
  select(
    section,
    variable,
    value,
    comment,
    declaration
  ) %>% 
  mutate(
    value = glue("<span data-tippy-content='CSS-value: {bs_get_variables(bs_theme(), variable)}'> {value} </span>")
  ) -> variables_df 
```

## Modifying Bootstrap theming variables

While a large amount of customization is possible with the basic parameters in `bs_theme()`, sometimes you may want more fine-grain control. To enable this, `bslib` lets you change any of the [exposed theming variables provided by Bootstrap.](https://getbootstrap.com/docs/4.0/getting-started/theming/) For instance, to adjust the padding amount after each paragraph we can use the variable [`paragraph-margin-bottom`](#paragraph-margin-bottom)...

```{r, eval = FALSE, echo = TRUE}
# Double space given after each paragraph
theme <- bs_theme(..., "paragraph-margin-bottom" = "2rem")
```

For more details on this see the [sass variables section of the theming article](https://rstudio.github.io/bslib/articles/theming.html#sass-variables-1) and the [original Bootstrap documentation of theme variables.](https://getbootstrap.com/docs/4.0/getting-started/theming/)


## All theming variables

Below is a table that shows all the available themeing variables along with basic comments on that variable's functionality as provided in the original Bootstrap code. 
_Note: these variables are specifically for Bootstrap 4 and many won't work for Bootstrap 3._

### How to use table

- Each section header corresponds to a section within the source file denoted by comments. Click on the link icon in the header to be taken to the start of that section in the variable declaration script. 
- Click on dependency variable within the value column to be taken to the declaration of that dependency in the table.
- Hover over the value to see the compiled CSS value produced. 
- The __Find in source__ column will take you to the position in the original `.scss` file where the variable was declared. The context may help clarify the variables role. 

```{js}
function find_and_select_variable(table, desired_var, update_page) {
  var row_index = table
    .column(1, { order: "current" })
    .data()
    .indexOf(desired_var);
  if (row_index !== -1) {
    table.rows({ selected: true }).deselect();
    table.row(row_index).select();
    location.hash = "#" + desired_var;

    if (update_page) {
      table.row(row_index).scrollTo();
    }
  }
}

function go_to_current_hash(table) {
  var desired_var = location.hash.replace("#", "");
  find_and_select_variable(table, desired_var, true);
}
```


```{r}
variables_df %>%
  rename(
    Variable = variable,
    Value = value,
    Comment = comment,
    `Find in source` = declaration
  ) %>% 
  DT::datatable(
    escape = FALSE,
    style = "bootstrap",
    class = "cell-border",
    rownames = FALSE,
    selection = "none",
    extensions = c("Select", "RowGroup", "Scroller"),
    callback = DT::JS("
      // Check for linked variable on first load                    
      go_to_current_hash(table);
      
      // Allows us to link within the page
      window.onhashchange = function() {
        go_to_current_hash(table);
      }"),
    options = list(
      deferRender = TRUE,
      scroller = TRUE,
      scrollY = 850,
      scrollX = TRUE,
      rowGroup = list(dataSrc = 0),
      drawCallback = DT::JS("
        function( settings ) {
          var table = this.DataTable();
        
          tippy('[data-tippy-content]', {placement: 'right'});
        
          // Hide section column from view
          table.column(0).visible(false);
          
          // This makes variable names themselves selectable for building urls etc  
          this.find('tbody td:nth-child(1)').on('click', function(){
            find_and_select_variable(table, this.innerText, false);
          })
        
          // This makes the dependencies linked
          this.find('span.dep-link').on('click', function(){
            find_and_select_variable(table, this.innerText.replace('$', ''), true);
          });
        }")
    )
  )
```



### What's the "`$`" doing in front of the variables?
You may notice in the table that the variables are prefixed with a `$` this is a `sass` convention and you should omit the `$` in your calls to `bs_theme()`. However, if you wanted to reference another variable in your declaration of a value, such as making the `dark` variable equal to `grey-900` instead of `grey-800`, you _would_ need to use the `$` prefix when referring to the dependency. Also, you will need to tell `bslib` to place its definition later than `grey-900`'s with `bs_add_variables(..., .where = "declarations")`:

```{r, eval = FALSE, echo = TRUE}
theme <- bs_theme(
  ...,
  "paragraph-margin-bottom" = "2rem"
) %>% 
  # When referring to other variables, prefix with dollar-sign
  bs_add_variables("dark" = "$gray-900", .where = "declarations")
```
